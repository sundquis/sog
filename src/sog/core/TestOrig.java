/*
 * Copyright (C) 2017-18 by TS Sundquist
 * 
 * All rights reserved.
 * 
 */

package sog.core;


import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import sog.core.test.CaseResultOrig;
import sog.core.test.ClassResultOrig;
import sog.core.test.MemberResultOrig;
import sog.core.test.ResultOrig;
import sog.core.test.TestCaseImpl;
import sog.core.test.TestResultOrig;
import sog.util.PriorityQueue;
import sog.util.Queue;

/**
 * Work Flow:
 * 		Annotate (Test.Decl) members of subject class to declare a test case
 * 		Framework generates method stubs (Test.Impl); copy into container class
 * 		Implement test case using TestCase interface to indicate results
 * 
 * Containers may be inner classes or top-level.
 * 
 * Inner container implementation example:
 * 
 * 		public static class Container implements TestContainer {
 * 
 * 			@Override
 * 			public Class<?> subjectClass() {
 * 				return MyApplication.class;
 * 			}
 * 
 * 			// Copied stubs, implemented using API presented by TestCase interface
 * 			@Test.Impl( ... )
 * 			public void subj_Description( TestCase tc ) {
 * 				...
 * 				tc.pass();
 * 			}
 * 
 * 		}
 * 
 * 
 * Test execution example:
 * 
 * 		new Test( Container.class );
 * 
 * 		[ repeat for additional application classes ]
 * 
 * 		Test.printResults(); 
 * 
 * 
 * Feedback:
 * 		Un-annotated elements generate warnings per the policy defined by properties in test.Results
 * 
 * 		Declared test cases without implementations generate stubs for container
 * 
 * 		Implementations without declarations (orphans) generate warnings
 * 
 * 		Results show multi-level summaries as specified by properties in test.Results
 * 
 * Class Structure: 3 roles 
 * 		Inner annotation definitions for declaring tests
 * 
 * 		Static members for managing global test display properties for a set of tests
 * 
 * 		Instance members for constructing and executing tests for one subject class
 * 
 * Concepts
 * 		Two types of annotations for identifying test cases.
 * 		Test.Decl( "Test description" ) declares a test case associated with a member. 
 * 			The description is part of the documentation of the member.
 * 		Test.Impl( ... ) marks the method implementing the test case. This is
 * 			generated by the test framework.
 * 
 * 		Result: an abstract base class for the tree of results associated with testing
 * 			TestResult -> ClassResult -> MemberResult -> CaseResult
 * 
 * 		This class (Test) manages the global set of results (static TestResult) for all
 * 		tests and the results (instance ClassResult) associated with one subject class.
 * 
 * 		In addition to pass/fail information (Results) there are two additional sets of
 * 		feedback information generated by testing:
 * 		Warnings: Elements of the subject class that do not have any test cases declared
 * 		Stubs: Method stubs for unimplemented test methods.
 * 
 * 		Each Test instance manages two classes.
 * 		Subject Class: The class being tested.
 * 		Container Class: The class containing the test methods.
 * 			A test is created with a container class
 * 				new Test( SomeContainerClass.class )
 * 			The constructor triggers execution of the tests
 * 			The container identifies the target subject class
 * 
 */
@TestOrig.Decl( "Loads correctly" )
public class TestOrig {
	
	
	/**
	 * Annotate class elements (containing class, member class, constructor, field, method)
	 * to declare a test case pertaining to the element.
	 */
	@TestOrig.Skip
	@Documented
	@Repeatable( Decls.class )
	@Retention( RetentionPolicy.RUNTIME )
	@Target( {ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE} )
	public @interface Decl {

		/**
		 * A brief description of the test case. It is used to generate the name of the 
		 * corresponding test method.
		 */
		String value();
		
	}
	
	/**
	 * Container for repeated test declarations
	 */
	@TestOrig.Skip
	@Documented
	@Retention( RetentionPolicy.RUNTIME )
	@Target( {ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE} )
	public @interface Decls {
		Decl[] value();
	}
	
	/**
	 * Marker for test implementation methods. These are generated by the test framework and generally
	 * should not be hand coded. In particular the {@code src} and {@code desc} fields are generated to 
	 * correspond to a test declaration.
	 * 
	 * The optional numeric fields may be included to adjust features of the test.
	 */
	@TestOrig.Skip
	@Retention( RetentionPolicy.RUNTIME )
	@Target( ElementType.METHOD )
	public @interface Impl {

		/** Do not edit. Must match the corresponding declaration */
		String src();
		
		/** Do not edit. Must match the corresponding declaration */
		String desc();

		/** CURRENTLY NOT USED */
		long timeout() default 0L;
		
		/** Used to control the order of execution of test methods */
		int priority() default 0;
		
		/** Used to scale the relative importance of the test case */
		int weight() default 1;
		
	}
	

	/**
	 * Used to indicate that the element (and contained elements of a class) should not
	 * be scanned for test cases. Can be used to mark simple components that do not require
	 * testing or components that are externally tested.
	 * 
	 * The optional string {@code value} can be used to describe alternate testing
	 */
	@TestOrig.Skip
	@Retention( RetentionPolicy.RUNTIME )
	@Target( {ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE} )
	public @interface Skip {
		
		String value() default "No test";
		
	}

	
	
	


	// Tree of results for all classes being tested
	// The root of the result tree
	private static final TestResultOrig testResult = new TestResultOrig();

	
	
	
	
	// Elements (MemberResult) that have no test declarations 
	// or (TestRunner) classes without containers generate warnings
	private static Collection<String> warnings = new TreeSet<String>();
	
	private static boolean showWarnings = true;

	/**
	 * Suppress all warnings.
	 */
	@TestOrig.Skip
	public static void noWarnings() {
		TestOrig.showWarnings = false;
	}

	/**
	 * Add a non-empty warning message.
	 */
	@Decl( "Throws assertion error if warning is null" )
	@Decl( "Throws assertion error if warning is empty" )
	public static void addWarning( String warning ) {
		Assert.nonEmpty( warning );
		
		synchronized ( TestOrig.warnings ) {
			TestOrig.warnings.add( warning );
		}
	}
	

	
	
	// Helper class for generating test case implementation stubs
	@TestOrig.Skip
	private static class Stub {
		private static final Set<String> MEMBER_NAMES = new TreeSet<>();
		
		private String member;
		private String description;
		private String subject;
		
		Stub( String member, String description, String subject ) {
			this.member = member;
			this.description = description;
			this.subject = subject;
		}
		
		@Override
		public String toString() {
			String mname = this.subject + "_" + Strings.toCamelCase( this.description );
			while ( MEMBER_NAMES.contains( mname ) ) {
				mname = mname + "_";
			}
			MEMBER_NAMES.add( mname );
			StringBuilder s = new StringBuilder();
			s.append( "@Test.Impl( src = \"" + this.member + "\", desc = \"" + this.description + "\" )\n" );
			s.append( "public void " + mname + "( TestCase tc ) {\n" );
			s.append( "\ttc.addMessage( \"GENERATED STUB\" ).fail();\n" );
			s.append( "}\n" );
			return s.toString();
		}
	}
	
	private static final List<Stub> stubs = new LinkedList<Stub>();
	
	private static boolean showStubs = true;
	
	@Skip
	public static void noStubs() {
		TestOrig.showStubs = false;
	}

	@Decl( "Throws assertion error if member is empty" )
	@Decl( "Throws assertion error if descrption is empty" )
	@Decl( "Throws assertion error if subject is empty" )
	public static void addStub( String member, String description, String subject ) {
		Assert.nonEmpty( member );
		Assert.nonEmpty( description );
		Assert.nonEmpty( subject );

		TestOrig.stubs.add( new Stub( member, description, subject ) );
	}


	
	
	
	/**
	 * Show only the top-level summary, class-level summary, and failure messages
	 */
	@TestOrig.Skip
	public static void summaryOnly() {
		ResultOrig.summary();
	}
	
	/**
	 * Turn on all forms of reporting.
	 */
	@TestOrig.Skip
	public static void verbose() {
		ResultOrig.verbose();
	}
	
	/**
	 * Print results from all tests.
	 * 
	 * Once this method has been called no subsequent results will be recorded so this should
	 * only be called after all tests finish.
	 */
	@TestOrig.Skip
	public static void printResults() {
		System.out.println();
		
		TestOrig.testResult.print( "" );

		if ( TestOrig.showWarnings ) {
			System.err.println( "\n\nWARNINGS:" );
			for ( String s : TestOrig.warnings ) {
				System.err.println( "\t" + s );
			}
		}

		if ( TestOrig.showStubs ) {
			System.err.println( "\nSTUBS:" );
			for ( Stub s : TestOrig.stubs) {
				System.err.println( s );
			}
		}
	}
	
	
	

	// Holds test methods for the subject class
	private TestContainer container;
	
	// Results associated with test cases for the associated subject class
	private final ClassResultOrig classResult;
	
	// Map from member.desription key to corresponding CaseResult
	// This combination is assumed to be unique over all test cases
	// This constraint is enforced by the naming conventions in the MemberResult constructors
	// This instance has a ClassResult with children MemberResult instances. These CaseResult
	// instances are children of the MemberResult instances. We need to maintain this map
	// (of grandchildren) so that we can construct test implementations (TestCaseImpl)
	private final Map<String, CaseResultOrig> caseResults;
	
	// Queue of TestCase instances awaiting evaluation.
	private final Queue<TestCaseImpl> queue;

	@Decl( "Throws assertion error for null container" )
	@Decl( "Fails for containers with illegal constructors" )
	public TestOrig( Class<? extends TestContainer> containerClass ) {
		Assert.nonNull( containerClass );
		
		try {
			this.container = containerClass.getDeclaredConstructor().newInstance();
		} catch ( Exception e ) {
			Fatal.error( "Failed to construct Test Container", e );
		}

		this.classResult = TestOrig.testResult.addClass( this.container.subjectClass() );
		this.caseResults = new TreeMap<String, CaseResultOrig>();
		this.queue = new PriorityQueue<TestCaseImpl>();
		
		this.scanSubject( this.container.subjectClass() );
		this.loadContainer();
		this.evaluateTests();
	}

	// Find all members that could have associated test cases.
	// Excluded: synthetic members, methods called main, container classes
	// Each member generates a MemberResult child for our ClassResult
	// If a member does not have a Test.Skip annotation (member.include() = true)
	// then its Test.Decl annotations generate CaseResult instances
	private void scanSubject( Class<?> clazz ) {
		MemberResultOrig mr = this.classResult.addMember( clazz );
		if ( ! mr.include() ) {
			return;
		}
		this.addAnnotations( mr );
		
		Constructor<?>[] constructors = clazz.getDeclaredConstructors();
		for ( Constructor<?> constructor : constructors ) {
			if ( ! constructor.isSynthetic() ) {
				mr = this.classResult.addMember( constructor );
				if ( mr.include() ) {
					this.addAnnotations( mr );
				}
			}
		}
		
		Field[] fields = clazz.getDeclaredFields();
		for ( Field field : fields ) {
			if ( ! field.isSynthetic() ) {
				mr = this.classResult.addMember( field );
				if ( mr.include() ) {
					this.addAnnotations( mr );
				}
			}
		}
		
		Method[] methods = clazz.getDeclaredMethods();
		for ( Method method : methods ) {
			if ( ! method.isSynthetic() && ! "main".equals( method.getName() ) ) {
				mr = this.classResult.addMember( method );
				if ( mr.include() ) {
					this.addAnnotations( mr );
				}
			}
		}
		
		Class<?>[] classes = clazz.getDeclaredClasses();
		for ( Class<?> c : classes ) {
			if ( ! TestContainer.class.isAssignableFrom( c ) ) {
				this.scanSubject( c );
			}
		}
	}

	@Decl( "Description's with; puc-tuation! handled... right?" )
	@Decl( "Can change name of generated method" )
	private void addAnnotations( MemberResultOrig mr ) {
		Decl[] declarations = mr.getAnnotations();
		for ( Decl d : declarations ) {
			if ( d.value().isEmpty() ) {
				Fatal.error( "Missing description on annotation for " + mr );
			}
			
			CaseResultOrig cr = mr.addCase( d );
			this.caseResults.put( cr.getKey(), cr );
		}
	}
	
	// The container has implementations of test methods. Use reflection to find them and
	// enqueue TestCase jobs
	private void loadContainer() {
		this.container.beforeAll().exec();
		
		TestCaseImpl testCaseImpl;
		Method[] methods = this.container.getClass().getDeclaredMethods();
		for ( Method method : methods ) {
			testCaseImpl = this.getTestCaseImpl( method, method.getAnnotation( Impl.class ) );
			if ( testCaseImpl != null ) {
				this.queue.put( testCaseImpl );
			}
		}
		
		this.queue.close();
	}
	
	private TestCaseImpl getTestCaseImpl( Method method, Impl impl ) {
		// The container may have various non-test methods
		if ( impl == null ) {
			return null;
		}
		
		CaseResultOrig cr = this.caseResults.get( impl.src() + "." + impl.desc() );
		
		// Can happen when Test.Decl is deleted, or when a method name changes
		if ( cr == null ) {
			TestOrig.addWarning( "Orphaned test case: " + impl.src() + ", " + impl.desc() );
			return null;
		}

		return new TestCaseImpl( impl, this.container, method, cr );
	}

	@Decl( "Handles cases in priority order." )
	private void evaluateTests() {
		TestCaseImpl tc;
		while ( (tc = this.queue.get()) != null ) {
			// Not designed to be executed concurrently but could be run in a separate thread 
			// and monitored. In that case should consult the Test.Impl.timeout() value
			tc.run();  
		}
		this.container.afterAll().exec();

		// Useful to see class result as progress indicator in multi-class testing
		System.out.println( this.classResult );
	}
	
	
}
